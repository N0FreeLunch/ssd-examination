// Code generated by ent, DO NOT EDIT.

package ent

import (
	"context"
	"errors"
	"fmt"
	"log"
	"reflect"

	"examination/internal/ent/migrate"

	"examination/internal/ent/choice"
	"examination/internal/ent/exam"
	"examination/internal/ent/problem"
	"examination/internal/ent/problemtranslation"
	"examination/internal/ent/section"
	"examination/internal/ent/topic"
	"examination/internal/ent/unit"
	"examination/internal/ent/versionrule"

	"entgo.io/ent"
	"entgo.io/ent/dialect"
	"entgo.io/ent/dialect/sql"
	"entgo.io/ent/dialect/sql/sqlgraph"
)

// Client is the client that holds all ent builders.
type Client struct {
	config
	// Schema is the client for creating, migrating and dropping schema.
	Schema *migrate.Schema
	// Choice is the client for interacting with the Choice builders.
	Choice *ChoiceClient
	// Exam is the client for interacting with the Exam builders.
	Exam *ExamClient
	// Problem is the client for interacting with the Problem builders.
	Problem *ProblemClient
	// ProblemTranslation is the client for interacting with the ProblemTranslation builders.
	ProblemTranslation *ProblemTranslationClient
	// Section is the client for interacting with the Section builders.
	Section *SectionClient
	// Topic is the client for interacting with the Topic builders.
	Topic *TopicClient
	// Unit is the client for interacting with the Unit builders.
	Unit *UnitClient
	// VersionRule is the client for interacting with the VersionRule builders.
	VersionRule *VersionRuleClient
}

// NewClient creates a new client configured with the given options.
func NewClient(opts ...Option) *Client {
	client := &Client{config: newConfig(opts...)}
	client.init()
	return client
}

func (c *Client) init() {
	c.Schema = migrate.NewSchema(c.driver)
	c.Choice = NewChoiceClient(c.config)
	c.Exam = NewExamClient(c.config)
	c.Problem = NewProblemClient(c.config)
	c.ProblemTranslation = NewProblemTranslationClient(c.config)
	c.Section = NewSectionClient(c.config)
	c.Topic = NewTopicClient(c.config)
	c.Unit = NewUnitClient(c.config)
	c.VersionRule = NewVersionRuleClient(c.config)
}

type (
	// config is the configuration for the client and its builder.
	config struct {
		// driver used for executing database requests.
		driver dialect.Driver
		// debug enable a debug logging.
		debug bool
		// log used for logging on debug mode.
		log func(...any)
		// hooks to execute on mutations.
		hooks *hooks
		// interceptors to execute on queries.
		inters *inters
	}
	// Option function to configure the client.
	Option func(*config)
)

// newConfig creates a new config for the client.
func newConfig(opts ...Option) config {
	cfg := config{log: log.Println, hooks: &hooks{}, inters: &inters{}}
	cfg.options(opts...)
	return cfg
}

// options applies the options on the config object.
func (c *config) options(opts ...Option) {
	for _, opt := range opts {
		opt(c)
	}
	if c.debug {
		c.driver = dialect.Debug(c.driver, c.log)
	}
}

// Debug enables debug logging on the ent.Driver.
func Debug() Option {
	return func(c *config) {
		c.debug = true
	}
}

// Log sets the logging function for debug mode.
func Log(fn func(...any)) Option {
	return func(c *config) {
		c.log = fn
	}
}

// Driver configures the client driver.
func Driver(driver dialect.Driver) Option {
	return func(c *config) {
		c.driver = driver
	}
}

// Open opens a database/sql.DB specified by the driver name and
// the data source name, and returns a new client attached to it.
// Optional parameters can be added for configuring the client.
func Open(driverName, dataSourceName string, options ...Option) (*Client, error) {
	switch driverName {
	case dialect.MySQL, dialect.Postgres, dialect.SQLite:
		drv, err := sql.Open(driverName, dataSourceName)
		if err != nil {
			return nil, err
		}
		return NewClient(append(options, Driver(drv))...), nil
	default:
		return nil, fmt.Errorf("unsupported driver: %q", driverName)
	}
}

// ErrTxStarted is returned when trying to start a new transaction from a transactional client.
var ErrTxStarted = errors.New("ent: cannot start a transaction within a transaction")

// Tx returns a new transactional client. The provided context
// is used until the transaction is committed or rolled back.
func (c *Client) Tx(ctx context.Context) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, ErrTxStarted
	}
	tx, err := newTx(ctx, c.driver)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = tx
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Choice:             NewChoiceClient(cfg),
		Exam:               NewExamClient(cfg),
		Problem:            NewProblemClient(cfg),
		ProblemTranslation: NewProblemTranslationClient(cfg),
		Section:            NewSectionClient(cfg),
		Topic:              NewTopicClient(cfg),
		Unit:               NewUnitClient(cfg),
		VersionRule:        NewVersionRuleClient(cfg),
	}, nil
}

// BeginTx returns a transactional client with specified options.
func (c *Client) BeginTx(ctx context.Context, opts *sql.TxOptions) (*Tx, error) {
	if _, ok := c.driver.(*txDriver); ok {
		return nil, errors.New("ent: cannot start a transaction within a transaction")
	}
	tx, err := c.driver.(interface {
		BeginTx(context.Context, *sql.TxOptions) (dialect.Tx, error)
	}).BeginTx(ctx, opts)
	if err != nil {
		return nil, fmt.Errorf("ent: starting a transaction: %w", err)
	}
	cfg := c.config
	cfg.driver = &txDriver{tx: tx, drv: c.driver}
	return &Tx{
		ctx:                ctx,
		config:             cfg,
		Choice:             NewChoiceClient(cfg),
		Exam:               NewExamClient(cfg),
		Problem:            NewProblemClient(cfg),
		ProblemTranslation: NewProblemTranslationClient(cfg),
		Section:            NewSectionClient(cfg),
		Topic:              NewTopicClient(cfg),
		Unit:               NewUnitClient(cfg),
		VersionRule:        NewVersionRuleClient(cfg),
	}, nil
}

// Debug returns a new debug-client. It's used to get verbose logging on specific operations.
//
//	client.Debug().
//		Choice.
//		Query().
//		Count(ctx)
func (c *Client) Debug() *Client {
	if c.debug {
		return c
	}
	cfg := c.config
	cfg.driver = dialect.Debug(c.driver, c.log)
	client := &Client{config: cfg}
	client.init()
	return client
}

// Close closes the database connection and prevents new queries from starting.
func (c *Client) Close() error {
	return c.driver.Close()
}

// Use adds the mutation hooks to all the entity clients.
// In order to add hooks to a specific client, call: `client.Node.Use(...)`.
func (c *Client) Use(hooks ...Hook) {
	for _, n := range []interface{ Use(...Hook) }{
		c.Choice, c.Exam, c.Problem, c.ProblemTranslation, c.Section, c.Topic, c.Unit,
		c.VersionRule,
	} {
		n.Use(hooks...)
	}
}

// Intercept adds the query interceptors to all the entity clients.
// In order to add interceptors to a specific client, call: `client.Node.Intercept(...)`.
func (c *Client) Intercept(interceptors ...Interceptor) {
	for _, n := range []interface{ Intercept(...Interceptor) }{
		c.Choice, c.Exam, c.Problem, c.ProblemTranslation, c.Section, c.Topic, c.Unit,
		c.VersionRule,
	} {
		n.Intercept(interceptors...)
	}
}

// Mutate implements the ent.Mutator interface.
func (c *Client) Mutate(ctx context.Context, m Mutation) (Value, error) {
	switch m := m.(type) {
	case *ChoiceMutation:
		return c.Choice.mutate(ctx, m)
	case *ExamMutation:
		return c.Exam.mutate(ctx, m)
	case *ProblemMutation:
		return c.Problem.mutate(ctx, m)
	case *ProblemTranslationMutation:
		return c.ProblemTranslation.mutate(ctx, m)
	case *SectionMutation:
		return c.Section.mutate(ctx, m)
	case *TopicMutation:
		return c.Topic.mutate(ctx, m)
	case *UnitMutation:
		return c.Unit.mutate(ctx, m)
	case *VersionRuleMutation:
		return c.VersionRule.mutate(ctx, m)
	default:
		return nil, fmt.Errorf("ent: unknown mutation type %T", m)
	}
}

// ChoiceClient is a client for the Choice schema.
type ChoiceClient struct {
	config
}

// NewChoiceClient returns a client for the Choice from the given config.
func NewChoiceClient(c config) *ChoiceClient {
	return &ChoiceClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `choice.Hooks(f(g(h())))`.
func (c *ChoiceClient) Use(hooks ...Hook) {
	c.hooks.Choice = append(c.hooks.Choice, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `choice.Intercept(f(g(h())))`.
func (c *ChoiceClient) Intercept(interceptors ...Interceptor) {
	c.inters.Choice = append(c.inters.Choice, interceptors...)
}

// Create returns a builder for creating a Choice entity.
func (c *ChoiceClient) Create() *ChoiceCreate {
	mutation := newChoiceMutation(c.config, OpCreate)
	return &ChoiceCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Choice entities.
func (c *ChoiceClient) CreateBulk(builders ...*ChoiceCreate) *ChoiceCreateBulk {
	return &ChoiceCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ChoiceClient) MapCreateBulk(slice any, setFunc func(*ChoiceCreate, int)) *ChoiceCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ChoiceCreateBulk{err: fmt.Errorf("calling to ChoiceClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ChoiceCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ChoiceCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Choice.
func (c *ChoiceClient) Update() *ChoiceUpdate {
	mutation := newChoiceMutation(c.config, OpUpdate)
	return &ChoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ChoiceClient) UpdateOne(_m *Choice) *ChoiceUpdateOne {
	mutation := newChoiceMutation(c.config, OpUpdateOne, withChoice(_m))
	return &ChoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ChoiceClient) UpdateOneID(id int) *ChoiceUpdateOne {
	mutation := newChoiceMutation(c.config, OpUpdateOne, withChoiceID(id))
	return &ChoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Choice.
func (c *ChoiceClient) Delete() *ChoiceDelete {
	mutation := newChoiceMutation(c.config, OpDelete)
	return &ChoiceDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ChoiceClient) DeleteOne(_m *Choice) *ChoiceDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ChoiceClient) DeleteOneID(id int) *ChoiceDeleteOne {
	builder := c.Delete().Where(choice.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ChoiceDeleteOne{builder}
}

// Query returns a query builder for Choice.
func (c *ChoiceClient) Query() *ChoiceQuery {
	return &ChoiceQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeChoice},
		inters: c.Interceptors(),
	}
}

// Get returns a Choice entity by its id.
func (c *ChoiceClient) Get(ctx context.Context, id int) (*Choice, error) {
	return c.Query().Where(choice.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ChoiceClient) GetX(ctx context.Context, id int) *Choice {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProblemTranslation queries the problem_translation edge of a Choice.
func (c *ChoiceClient) QueryProblemTranslation(_m *Choice) *ProblemTranslationQuery {
	query := (&ProblemTranslationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(choice.Table, choice.FieldID, id),
			sqlgraph.To(problemtranslation.Table, problemtranslation.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, choice.ProblemTranslationTable, choice.ProblemTranslationColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ChoiceClient) Hooks() []Hook {
	return c.hooks.Choice
}

// Interceptors returns the client interceptors.
func (c *ChoiceClient) Interceptors() []Interceptor {
	return c.inters.Choice
}

func (c *ChoiceClient) mutate(ctx context.Context, m *ChoiceMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ChoiceCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ChoiceUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ChoiceUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ChoiceDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Choice mutation op: %q", m.Op())
	}
}

// ExamClient is a client for the Exam schema.
type ExamClient struct {
	config
}

// NewExamClient returns a client for the Exam from the given config.
func NewExamClient(c config) *ExamClient {
	return &ExamClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `exam.Hooks(f(g(h())))`.
func (c *ExamClient) Use(hooks ...Hook) {
	c.hooks.Exam = append(c.hooks.Exam, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `exam.Intercept(f(g(h())))`.
func (c *ExamClient) Intercept(interceptors ...Interceptor) {
	c.inters.Exam = append(c.inters.Exam, interceptors...)
}

// Create returns a builder for creating a Exam entity.
func (c *ExamClient) Create() *ExamCreate {
	mutation := newExamMutation(c.config, OpCreate)
	return &ExamCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Exam entities.
func (c *ExamClient) CreateBulk(builders ...*ExamCreate) *ExamCreateBulk {
	return &ExamCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ExamClient) MapCreateBulk(slice any, setFunc func(*ExamCreate, int)) *ExamCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ExamCreateBulk{err: fmt.Errorf("calling to ExamClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ExamCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ExamCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Exam.
func (c *ExamClient) Update() *ExamUpdate {
	mutation := newExamMutation(c.config, OpUpdate)
	return &ExamUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ExamClient) UpdateOne(_m *Exam) *ExamUpdateOne {
	mutation := newExamMutation(c.config, OpUpdateOne, withExam(_m))
	return &ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ExamClient) UpdateOneID(id int) *ExamUpdateOne {
	mutation := newExamMutation(c.config, OpUpdateOne, withExamID(id))
	return &ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Exam.
func (c *ExamClient) Delete() *ExamDelete {
	mutation := newExamMutation(c.config, OpDelete)
	return &ExamDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ExamClient) DeleteOne(_m *Exam) *ExamDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ExamClient) DeleteOneID(id int) *ExamDeleteOne {
	builder := c.Delete().Where(exam.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ExamDeleteOne{builder}
}

// Query returns a query builder for Exam.
func (c *ExamClient) Query() *ExamQuery {
	return &ExamQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeExam},
		inters: c.Interceptors(),
	}
}

// Get returns a Exam entity by its id.
func (c *ExamClient) Get(ctx context.Context, id int) (*Exam, error) {
	return c.Query().Where(exam.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ExamClient) GetX(ctx context.Context, id int) *Exam {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QuerySections queries the sections edge of a Exam.
func (c *ExamClient) QuerySections(_m *Exam) *SectionQuery {
	query := (&SectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.SectionsTable, exam.SectionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTopics queries the topics edge of a Exam.
func (c *ExamClient) QueryTopics(_m *Exam) *TopicQuery {
	query := (&TopicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(topic.Table, topic.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.TopicsTable, exam.TopicsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnits queries the units edge of a Exam.
func (c *ExamClient) QueryUnits(_m *Exam) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.UnitsTable, exam.UnitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersionRules queries the version_rules edge of a Exam.
func (c *ExamClient) QueryVersionRules(_m *Exam) *VersionRuleQuery {
	query := (&VersionRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(exam.Table, exam.FieldID, id),
			sqlgraph.To(versionrule.Table, versionrule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, exam.VersionRulesTable, exam.VersionRulesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ExamClient) Hooks() []Hook {
	return c.hooks.Exam
}

// Interceptors returns the client interceptors.
func (c *ExamClient) Interceptors() []Interceptor {
	return c.inters.Exam
}

func (c *ExamClient) mutate(ctx context.Context, m *ExamMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ExamCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ExamUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ExamUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ExamDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Exam mutation op: %q", m.Op())
	}
}

// ProblemClient is a client for the Problem schema.
type ProblemClient struct {
	config
}

// NewProblemClient returns a client for the Problem from the given config.
func NewProblemClient(c config) *ProblemClient {
	return &ProblemClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `problem.Hooks(f(g(h())))`.
func (c *ProblemClient) Use(hooks ...Hook) {
	c.hooks.Problem = append(c.hooks.Problem, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `problem.Intercept(f(g(h())))`.
func (c *ProblemClient) Intercept(interceptors ...Interceptor) {
	c.inters.Problem = append(c.inters.Problem, interceptors...)
}

// Create returns a builder for creating a Problem entity.
func (c *ProblemClient) Create() *ProblemCreate {
	mutation := newProblemMutation(c.config, OpCreate)
	return &ProblemCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Problem entities.
func (c *ProblemClient) CreateBulk(builders ...*ProblemCreate) *ProblemCreateBulk {
	return &ProblemCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProblemClient) MapCreateBulk(slice any, setFunc func(*ProblemCreate, int)) *ProblemCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProblemCreateBulk{err: fmt.Errorf("calling to ProblemClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProblemCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProblemCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Problem.
func (c *ProblemClient) Update() *ProblemUpdate {
	mutation := newProblemMutation(c.config, OpUpdate)
	return &ProblemUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProblemClient) UpdateOne(_m *Problem) *ProblemUpdateOne {
	mutation := newProblemMutation(c.config, OpUpdateOne, withProblem(_m))
	return &ProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProblemClient) UpdateOneID(id int) *ProblemUpdateOne {
	mutation := newProblemMutation(c.config, OpUpdateOne, withProblemID(id))
	return &ProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Problem.
func (c *ProblemClient) Delete() *ProblemDelete {
	mutation := newProblemMutation(c.config, OpDelete)
	return &ProblemDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProblemClient) DeleteOne(_m *Problem) *ProblemDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProblemClient) DeleteOneID(id int) *ProblemDeleteOne {
	builder := c.Delete().Where(problem.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProblemDeleteOne{builder}
}

// Query returns a query builder for Problem.
func (c *ProblemClient) Query() *ProblemQuery {
	return &ProblemQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProblem},
		inters: c.Interceptors(),
	}
}

// Get returns a Problem entity by its id.
func (c *ProblemClient) Get(ctx context.Context, id int) (*Problem, error) {
	return c.Query().Where(problem.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProblemClient) GetX(ctx context.Context, id int) *Problem {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryUnit queries the unit edge of a Problem.
func (c *ProblemClient) QueryUnit(_m *Problem) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problem.Table, problem.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, problem.UnitTable, problem.UnitColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryVersions queries the versions edge of a Problem.
func (c *ProblemClient) QueryVersions(_m *Problem) *VersionRuleQuery {
	query := (&VersionRuleClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problem.Table, problem.FieldID, id),
			sqlgraph.To(versionrule.Table, versionrule.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, problem.VersionsTable, problem.VersionsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTranslations queries the translations edge of a Problem.
func (c *ProblemClient) QueryTranslations(_m *Problem) *ProblemTranslationQuery {
	query := (&ProblemTranslationClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problem.Table, problem.FieldID, id),
			sqlgraph.To(problemtranslation.Table, problemtranslation.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, problem.TranslationsTable, problem.TranslationsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryParent queries the parent edge of a Problem.
func (c *ProblemClient) QueryParent(_m *Problem) *ProblemQuery {
	query := (&ProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problem.Table, problem.FieldID, id),
			sqlgraph.To(problem.Table, problem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, problem.ParentTable, problem.ParentColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChildren queries the children edge of a Problem.
func (c *ProblemClient) QueryChildren(_m *Problem) *ProblemQuery {
	query := (&ProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problem.Table, problem.FieldID, id),
			sqlgraph.To(problem.Table, problem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, problem.ChildrenTable, problem.ChildrenColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProblemClient) Hooks() []Hook {
	return c.hooks.Problem
}

// Interceptors returns the client interceptors.
func (c *ProblemClient) Interceptors() []Interceptor {
	return c.inters.Problem
}

func (c *ProblemClient) mutate(ctx context.Context, m *ProblemMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProblemCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProblemUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProblemUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProblemDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Problem mutation op: %q", m.Op())
	}
}

// ProblemTranslationClient is a client for the ProblemTranslation schema.
type ProblemTranslationClient struct {
	config
}

// NewProblemTranslationClient returns a client for the ProblemTranslation from the given config.
func NewProblemTranslationClient(c config) *ProblemTranslationClient {
	return &ProblemTranslationClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `problemtranslation.Hooks(f(g(h())))`.
func (c *ProblemTranslationClient) Use(hooks ...Hook) {
	c.hooks.ProblemTranslation = append(c.hooks.ProblemTranslation, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `problemtranslation.Intercept(f(g(h())))`.
func (c *ProblemTranslationClient) Intercept(interceptors ...Interceptor) {
	c.inters.ProblemTranslation = append(c.inters.ProblemTranslation, interceptors...)
}

// Create returns a builder for creating a ProblemTranslation entity.
func (c *ProblemTranslationClient) Create() *ProblemTranslationCreate {
	mutation := newProblemTranslationMutation(c.config, OpCreate)
	return &ProblemTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of ProblemTranslation entities.
func (c *ProblemTranslationClient) CreateBulk(builders ...*ProblemTranslationCreate) *ProblemTranslationCreateBulk {
	return &ProblemTranslationCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *ProblemTranslationClient) MapCreateBulk(slice any, setFunc func(*ProblemTranslationCreate, int)) *ProblemTranslationCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &ProblemTranslationCreateBulk{err: fmt.Errorf("calling to ProblemTranslationClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*ProblemTranslationCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &ProblemTranslationCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for ProblemTranslation.
func (c *ProblemTranslationClient) Update() *ProblemTranslationUpdate {
	mutation := newProblemTranslationMutation(c.config, OpUpdate)
	return &ProblemTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *ProblemTranslationClient) UpdateOne(_m *ProblemTranslation) *ProblemTranslationUpdateOne {
	mutation := newProblemTranslationMutation(c.config, OpUpdateOne, withProblemTranslation(_m))
	return &ProblemTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *ProblemTranslationClient) UpdateOneID(id int) *ProblemTranslationUpdateOne {
	mutation := newProblemTranslationMutation(c.config, OpUpdateOne, withProblemTranslationID(id))
	return &ProblemTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for ProblemTranslation.
func (c *ProblemTranslationClient) Delete() *ProblemTranslationDelete {
	mutation := newProblemTranslationMutation(c.config, OpDelete)
	return &ProblemTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *ProblemTranslationClient) DeleteOne(_m *ProblemTranslation) *ProblemTranslationDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *ProblemTranslationClient) DeleteOneID(id int) *ProblemTranslationDeleteOne {
	builder := c.Delete().Where(problemtranslation.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &ProblemTranslationDeleteOne{builder}
}

// Query returns a query builder for ProblemTranslation.
func (c *ProblemTranslationClient) Query() *ProblemTranslationQuery {
	return &ProblemTranslationQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeProblemTranslation},
		inters: c.Interceptors(),
	}
}

// Get returns a ProblemTranslation entity by its id.
func (c *ProblemTranslationClient) Get(ctx context.Context, id int) (*ProblemTranslation, error) {
	return c.Query().Where(problemtranslation.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *ProblemTranslationClient) GetX(ctx context.Context, id int) *ProblemTranslation {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryProblem queries the problem edge of a ProblemTranslation.
func (c *ProblemTranslationClient) QueryProblem(_m *ProblemTranslation) *ProblemQuery {
	query := (&ProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problemtranslation.Table, problemtranslation.FieldID, id),
			sqlgraph.To(problem.Table, problem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, problemtranslation.ProblemTable, problemtranslation.ProblemColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryChoices queries the choices edge of a ProblemTranslation.
func (c *ProblemTranslationClient) QueryChoices(_m *ProblemTranslation) *ChoiceQuery {
	query := (&ChoiceClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(problemtranslation.Table, problemtranslation.FieldID, id),
			sqlgraph.To(choice.Table, choice.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, problemtranslation.ChoicesTable, problemtranslation.ChoicesColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *ProblemTranslationClient) Hooks() []Hook {
	return c.hooks.ProblemTranslation
}

// Interceptors returns the client interceptors.
func (c *ProblemTranslationClient) Interceptors() []Interceptor {
	return c.inters.ProblemTranslation
}

func (c *ProblemTranslationClient) mutate(ctx context.Context, m *ProblemTranslationMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&ProblemTranslationCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&ProblemTranslationUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&ProblemTranslationUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&ProblemTranslationDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown ProblemTranslation mutation op: %q", m.Op())
	}
}

// SectionClient is a client for the Section schema.
type SectionClient struct {
	config
}

// NewSectionClient returns a client for the Section from the given config.
func NewSectionClient(c config) *SectionClient {
	return &SectionClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `section.Hooks(f(g(h())))`.
func (c *SectionClient) Use(hooks ...Hook) {
	c.hooks.Section = append(c.hooks.Section, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `section.Intercept(f(g(h())))`.
func (c *SectionClient) Intercept(interceptors ...Interceptor) {
	c.inters.Section = append(c.inters.Section, interceptors...)
}

// Create returns a builder for creating a Section entity.
func (c *SectionClient) Create() *SectionCreate {
	mutation := newSectionMutation(c.config, OpCreate)
	return &SectionCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Section entities.
func (c *SectionClient) CreateBulk(builders ...*SectionCreate) *SectionCreateBulk {
	return &SectionCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *SectionClient) MapCreateBulk(slice any, setFunc func(*SectionCreate, int)) *SectionCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &SectionCreateBulk{err: fmt.Errorf("calling to SectionClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*SectionCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &SectionCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Section.
func (c *SectionClient) Update() *SectionUpdate {
	mutation := newSectionMutation(c.config, OpUpdate)
	return &SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *SectionClient) UpdateOne(_m *Section) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSection(_m))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *SectionClient) UpdateOneID(id int) *SectionUpdateOne {
	mutation := newSectionMutation(c.config, OpUpdateOne, withSectionID(id))
	return &SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Section.
func (c *SectionClient) Delete() *SectionDelete {
	mutation := newSectionMutation(c.config, OpDelete)
	return &SectionDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *SectionClient) DeleteOne(_m *Section) *SectionDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *SectionClient) DeleteOneID(id int) *SectionDeleteOne {
	builder := c.Delete().Where(section.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &SectionDeleteOne{builder}
}

// Query returns a query builder for Section.
func (c *SectionClient) Query() *SectionQuery {
	return &SectionQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeSection},
		inters: c.Interceptors(),
	}
}

// Get returns a Section entity by its id.
func (c *SectionClient) Get(ctx context.Context, id int) (*Section, error) {
	return c.Query().Where(section.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *SectionClient) GetX(ctx context.Context, id int) *Section {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a Section.
func (c *SectionClient) QueryExam(_m *Section) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(section.Table, section.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, section.ExamTable, section.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTopics queries the topics edge of a Section.
func (c *SectionClient) QueryTopics(_m *Section) *TopicQuery {
	query := (&TopicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(section.Table, section.FieldID, id),
			sqlgraph.To(topic.Table, topic.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, section.TopicsTable, section.TopicsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnits queries the units edge of a Section.
func (c *SectionClient) QueryUnits(_m *Section) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(section.Table, section.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, section.UnitsTable, section.UnitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *SectionClient) Hooks() []Hook {
	return c.hooks.Section
}

// Interceptors returns the client interceptors.
func (c *SectionClient) Interceptors() []Interceptor {
	return c.inters.Section
}

func (c *SectionClient) mutate(ctx context.Context, m *SectionMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&SectionCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&SectionUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&SectionUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&SectionDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Section mutation op: %q", m.Op())
	}
}

// TopicClient is a client for the Topic schema.
type TopicClient struct {
	config
}

// NewTopicClient returns a client for the Topic from the given config.
func NewTopicClient(c config) *TopicClient {
	return &TopicClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `topic.Hooks(f(g(h())))`.
func (c *TopicClient) Use(hooks ...Hook) {
	c.hooks.Topic = append(c.hooks.Topic, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `topic.Intercept(f(g(h())))`.
func (c *TopicClient) Intercept(interceptors ...Interceptor) {
	c.inters.Topic = append(c.inters.Topic, interceptors...)
}

// Create returns a builder for creating a Topic entity.
func (c *TopicClient) Create() *TopicCreate {
	mutation := newTopicMutation(c.config, OpCreate)
	return &TopicCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Topic entities.
func (c *TopicClient) CreateBulk(builders ...*TopicCreate) *TopicCreateBulk {
	return &TopicCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *TopicClient) MapCreateBulk(slice any, setFunc func(*TopicCreate, int)) *TopicCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &TopicCreateBulk{err: fmt.Errorf("calling to TopicClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*TopicCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &TopicCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Topic.
func (c *TopicClient) Update() *TopicUpdate {
	mutation := newTopicMutation(c.config, OpUpdate)
	return &TopicUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *TopicClient) UpdateOne(_m *Topic) *TopicUpdateOne {
	mutation := newTopicMutation(c.config, OpUpdateOne, withTopic(_m))
	return &TopicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *TopicClient) UpdateOneID(id int) *TopicUpdateOne {
	mutation := newTopicMutation(c.config, OpUpdateOne, withTopicID(id))
	return &TopicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Topic.
func (c *TopicClient) Delete() *TopicDelete {
	mutation := newTopicMutation(c.config, OpDelete)
	return &TopicDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *TopicClient) DeleteOne(_m *Topic) *TopicDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *TopicClient) DeleteOneID(id int) *TopicDeleteOne {
	builder := c.Delete().Where(topic.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &TopicDeleteOne{builder}
}

// Query returns a query builder for Topic.
func (c *TopicClient) Query() *TopicQuery {
	return &TopicQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeTopic},
		inters: c.Interceptors(),
	}
}

// Get returns a Topic entity by its id.
func (c *TopicClient) Get(ctx context.Context, id int) (*Topic, error) {
	return c.Query().Where(topic.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *TopicClient) GetX(ctx context.Context, id int) *Topic {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a Topic.
func (c *TopicClient) QueryExam(_m *Topic) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(topic.Table, topic.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, topic.ExamTable, topic.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySection queries the section edge of a Topic.
func (c *TopicClient) QuerySection(_m *Topic) *SectionQuery {
	query := (&SectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(topic.Table, topic.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, topic.SectionTable, topic.SectionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryUnits queries the units edge of a Topic.
func (c *TopicClient) QueryUnits(_m *Topic) *UnitQuery {
	query := (&UnitClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(topic.Table, topic.FieldID, id),
			sqlgraph.To(unit.Table, unit.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, topic.UnitsTable, topic.UnitsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *TopicClient) Hooks() []Hook {
	return c.hooks.Topic
}

// Interceptors returns the client interceptors.
func (c *TopicClient) Interceptors() []Interceptor {
	return c.inters.Topic
}

func (c *TopicClient) mutate(ctx context.Context, m *TopicMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&TopicCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&TopicUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&TopicUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&TopicDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Topic mutation op: %q", m.Op())
	}
}

// UnitClient is a client for the Unit schema.
type UnitClient struct {
	config
}

// NewUnitClient returns a client for the Unit from the given config.
func NewUnitClient(c config) *UnitClient {
	return &UnitClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `unit.Hooks(f(g(h())))`.
func (c *UnitClient) Use(hooks ...Hook) {
	c.hooks.Unit = append(c.hooks.Unit, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `unit.Intercept(f(g(h())))`.
func (c *UnitClient) Intercept(interceptors ...Interceptor) {
	c.inters.Unit = append(c.inters.Unit, interceptors...)
}

// Create returns a builder for creating a Unit entity.
func (c *UnitClient) Create() *UnitCreate {
	mutation := newUnitMutation(c.config, OpCreate)
	return &UnitCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of Unit entities.
func (c *UnitClient) CreateBulk(builders ...*UnitCreate) *UnitCreateBulk {
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *UnitClient) MapCreateBulk(slice any, setFunc func(*UnitCreate, int)) *UnitCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &UnitCreateBulk{err: fmt.Errorf("calling to UnitClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*UnitCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &UnitCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for Unit.
func (c *UnitClient) Update() *UnitUpdate {
	mutation := newUnitMutation(c.config, OpUpdate)
	return &UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *UnitClient) UpdateOne(_m *Unit) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnit(_m))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *UnitClient) UpdateOneID(id int) *UnitUpdateOne {
	mutation := newUnitMutation(c.config, OpUpdateOne, withUnitID(id))
	return &UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for Unit.
func (c *UnitClient) Delete() *UnitDelete {
	mutation := newUnitMutation(c.config, OpDelete)
	return &UnitDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *UnitClient) DeleteOne(_m *Unit) *UnitDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *UnitClient) DeleteOneID(id int) *UnitDeleteOne {
	builder := c.Delete().Where(unit.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &UnitDeleteOne{builder}
}

// Query returns a query builder for Unit.
func (c *UnitClient) Query() *UnitQuery {
	return &UnitQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeUnit},
		inters: c.Interceptors(),
	}
}

// Get returns a Unit entity by its id.
func (c *UnitClient) Get(ctx context.Context, id int) (*Unit, error) {
	return c.Query().Where(unit.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *UnitClient) GetX(ctx context.Context, id int) *Unit {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a Unit.
func (c *UnitClient) QueryExam(_m *Unit) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, unit.ExamTable, unit.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QuerySection queries the section edge of a Unit.
func (c *UnitClient) QuerySection(_m *Unit) *SectionQuery {
	query := (&SectionClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(section.Table, section.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, unit.SectionTable, unit.SectionColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryTopic queries the topic edge of a Unit.
func (c *UnitClient) QueryTopic(_m *Unit) *TopicQuery {
	query := (&TopicClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(topic.Table, topic.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, unit.TopicTable, unit.TopicColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProblems queries the problems edge of a Unit.
func (c *UnitClient) QueryProblems(_m *Unit) *ProblemQuery {
	query := (&ProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(unit.Table, unit.FieldID, id),
			sqlgraph.To(problem.Table, problem.FieldID),
			sqlgraph.Edge(sqlgraph.O2M, false, unit.ProblemsTable, unit.ProblemsColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *UnitClient) Hooks() []Hook {
	hooks := c.hooks.Unit
	return append(hooks[:len(hooks):len(hooks)], unit.Hooks[:]...)
}

// Interceptors returns the client interceptors.
func (c *UnitClient) Interceptors() []Interceptor {
	return c.inters.Unit
}

func (c *UnitClient) mutate(ctx context.Context, m *UnitMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&UnitCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&UnitUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&UnitUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&UnitDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown Unit mutation op: %q", m.Op())
	}
}

// VersionRuleClient is a client for the VersionRule schema.
type VersionRuleClient struct {
	config
}

// NewVersionRuleClient returns a client for the VersionRule from the given config.
func NewVersionRuleClient(c config) *VersionRuleClient {
	return &VersionRuleClient{config: c}
}

// Use adds a list of mutation hooks to the hooks stack.
// A call to `Use(f, g, h)` equals to `versionrule.Hooks(f(g(h())))`.
func (c *VersionRuleClient) Use(hooks ...Hook) {
	c.hooks.VersionRule = append(c.hooks.VersionRule, hooks...)
}

// Intercept adds a list of query interceptors to the interceptors stack.
// A call to `Intercept(f, g, h)` equals to `versionrule.Intercept(f(g(h())))`.
func (c *VersionRuleClient) Intercept(interceptors ...Interceptor) {
	c.inters.VersionRule = append(c.inters.VersionRule, interceptors...)
}

// Create returns a builder for creating a VersionRule entity.
func (c *VersionRuleClient) Create() *VersionRuleCreate {
	mutation := newVersionRuleMutation(c.config, OpCreate)
	return &VersionRuleCreate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// CreateBulk returns a builder for creating a bulk of VersionRule entities.
func (c *VersionRuleClient) CreateBulk(builders ...*VersionRuleCreate) *VersionRuleCreateBulk {
	return &VersionRuleCreateBulk{config: c.config, builders: builders}
}

// MapCreateBulk creates a bulk creation builder from the given slice. For each item in the slice, the function creates
// a builder and applies setFunc on it.
func (c *VersionRuleClient) MapCreateBulk(slice any, setFunc func(*VersionRuleCreate, int)) *VersionRuleCreateBulk {
	rv := reflect.ValueOf(slice)
	if rv.Kind() != reflect.Slice {
		return &VersionRuleCreateBulk{err: fmt.Errorf("calling to VersionRuleClient.MapCreateBulk with wrong type %T, need slice", slice)}
	}
	builders := make([]*VersionRuleCreate, rv.Len())
	for i := 0; i < rv.Len(); i++ {
		builders[i] = c.Create()
		setFunc(builders[i], i)
	}
	return &VersionRuleCreateBulk{config: c.config, builders: builders}
}

// Update returns an update builder for VersionRule.
func (c *VersionRuleClient) Update() *VersionRuleUpdate {
	mutation := newVersionRuleMutation(c.config, OpUpdate)
	return &VersionRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOne returns an update builder for the given entity.
func (c *VersionRuleClient) UpdateOne(_m *VersionRule) *VersionRuleUpdateOne {
	mutation := newVersionRuleMutation(c.config, OpUpdateOne, withVersionRule(_m))
	return &VersionRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// UpdateOneID returns an update builder for the given id.
func (c *VersionRuleClient) UpdateOneID(id int) *VersionRuleUpdateOne {
	mutation := newVersionRuleMutation(c.config, OpUpdateOne, withVersionRuleID(id))
	return &VersionRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// Delete returns a delete builder for VersionRule.
func (c *VersionRuleClient) Delete() *VersionRuleDelete {
	mutation := newVersionRuleMutation(c.config, OpDelete)
	return &VersionRuleDelete{config: c.config, hooks: c.Hooks(), mutation: mutation}
}

// DeleteOne returns a builder for deleting the given entity.
func (c *VersionRuleClient) DeleteOne(_m *VersionRule) *VersionRuleDeleteOne {
	return c.DeleteOneID(_m.ID)
}

// DeleteOneID returns a builder for deleting the given entity by its id.
func (c *VersionRuleClient) DeleteOneID(id int) *VersionRuleDeleteOne {
	builder := c.Delete().Where(versionrule.ID(id))
	builder.mutation.id = &id
	builder.mutation.op = OpDeleteOne
	return &VersionRuleDeleteOne{builder}
}

// Query returns a query builder for VersionRule.
func (c *VersionRuleClient) Query() *VersionRuleQuery {
	return &VersionRuleQuery{
		config: c.config,
		ctx:    &QueryContext{Type: TypeVersionRule},
		inters: c.Interceptors(),
	}
}

// Get returns a VersionRule entity by its id.
func (c *VersionRuleClient) Get(ctx context.Context, id int) (*VersionRule, error) {
	return c.Query().Where(versionrule.ID(id)).Only(ctx)
}

// GetX is like Get, but panics if an error occurs.
func (c *VersionRuleClient) GetX(ctx context.Context, id int) *VersionRule {
	obj, err := c.Get(ctx, id)
	if err != nil {
		panic(err)
	}
	return obj
}

// QueryExam queries the exam edge of a VersionRule.
func (c *VersionRuleClient) QueryExam(_m *VersionRule) *ExamQuery {
	query := (&ExamClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(versionrule.Table, versionrule.FieldID, id),
			sqlgraph.To(exam.Table, exam.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, versionrule.ExamTable, versionrule.ExamColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// QueryProblem queries the problem edge of a VersionRule.
func (c *VersionRuleClient) QueryProblem(_m *VersionRule) *ProblemQuery {
	query := (&ProblemClient{config: c.config}).Query()
	query.path = func(context.Context) (fromV *sql.Selector, _ error) {
		id := _m.ID
		step := sqlgraph.NewStep(
			sqlgraph.From(versionrule.Table, versionrule.FieldID, id),
			sqlgraph.To(problem.Table, problem.FieldID),
			sqlgraph.Edge(sqlgraph.M2O, true, versionrule.ProblemTable, versionrule.ProblemColumn),
		)
		fromV = sqlgraph.Neighbors(_m.driver.Dialect(), step)
		return fromV, nil
	}
	return query
}

// Hooks returns the client hooks.
func (c *VersionRuleClient) Hooks() []Hook {
	return c.hooks.VersionRule
}

// Interceptors returns the client interceptors.
func (c *VersionRuleClient) Interceptors() []Interceptor {
	return c.inters.VersionRule
}

func (c *VersionRuleClient) mutate(ctx context.Context, m *VersionRuleMutation) (Value, error) {
	switch m.Op() {
	case OpCreate:
		return (&VersionRuleCreate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdate:
		return (&VersionRuleUpdate{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpUpdateOne:
		return (&VersionRuleUpdateOne{config: c.config, hooks: c.Hooks(), mutation: m}).Save(ctx)
	case OpDelete, OpDeleteOne:
		return (&VersionRuleDelete{config: c.config, hooks: c.Hooks(), mutation: m}).Exec(ctx)
	default:
		return nil, fmt.Errorf("ent: unknown VersionRule mutation op: %q", m.Op())
	}
}

// hooks and interceptors per client, for fast access.
type (
	hooks struct {
		Choice, Exam, Problem, ProblemTranslation, Section, Topic, Unit,
		VersionRule []ent.Hook
	}
	inters struct {
		Choice, Exam, Problem, ProblemTranslation, Section, Topic, Unit,
		VersionRule []ent.Interceptor
	}
)
